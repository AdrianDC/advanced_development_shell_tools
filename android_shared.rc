# ======================================
#   Developed by Adrian DC - 2015-2016
# ======================================

# === Kernel Fast Builder ===
function fboota()
{
  cwd=$(pwd);
  croot;
  tmpfile=$(mktemp);

  echo "";
  echo -e " \e[1;37m[ Fast Kernel Builder by Adrian DC - 2016 ]\e[0m";
  echo "";
  sudo printf "";

  touch 'device/sony/huashan/rootdir/init.qcom.rc';

  if [[ "$1" =~ "sep" ]]; then
    mmm -B -j$(grep -c ^processor /proc/cpuinfo) ./external/sepolicy/;
  fi;

  if [[ ! "$1" =~ "full" ]] && $(mms -v >/dev/null 2>&1); then
    mms bootimage | tee $tmpfile;
  else
    make -j$(grep -c ^processor /proc/cpuinfo) bootimage | tee $tmpfile;
  fi;

  BootImg=$(grep -a ".*image.*boot\.img" $tmpfile | head -1 \
          | sed "s/.*: \(.*boot\.img\).*/\1/g");

  if [ ! -z "$BootImg" ] && [ -f "$BootImg" ]; then
    ModulesDir=$(grep -a ".*system/lib/.*" $tmpfile | head -1 \
               | sed "s/.* \(\S*system\/lib\/modules\S*\);.*/\1/g");
    Modules=$(grep -a ".*INSTALL .*\.ko.*" $tmpfile \
            | sed "s/.*INSTALL \(.*\.ko\).*/\1/g" \
            | uniq);
    echo ""; echo "";
    echo -e " \e[1;37m[ Waiting for adb root... ]\e[0m"; echo "";
    timeout 10 adb wait-for-device

    if [ ! -z "$Modules" ]; then
      adb remount;
      timeout 10 adb wait-for-device
      for Module in ${Modules[*]}; do
        ModuleFile=$(basename "$Module");
        adb push "$ModulesDir/$ModuleFile" "/system/lib/modules/$ModuleFile";
      done;
    fi;

    echo ""; echo -e " \e[1;37m[ Bootloader $BootImg... ]\e[0m"; echo "";
    sudo adb reboot bootloader;
    timeout 20 sudo fastboot flash boot "$BootImg";
    timeout 5 sudo fastboot reboot;
    echo "";
  fi;
  rm -f $tmpfile;
  cd $cwd;
  echo "";
}

# === Module Zip Maker ===
function mmmzip()
{
  CurDir=$(pwd);
  TmpDir=$(mktemp -d);
  BuildParams="$@";
  LogFile="$TmpDir/mmm_logs.txt";
  OutFile="pack-"$(date +'%Y%m%d-%H%M')"-$(basename $(readlink -f $1))-${TARGET_PRODUCT}.zip";
  TargetFile="$(xdg-user-dir DESKTOP)/Builds/$OutFile";
  mkdir -p $(dirname $TargetFile);
  path=$(readlink -f "$1");
  if [ ! -d "$path" ]; then
    croot;
  fi;

  if [ -z "$BuildParams" ]; then
    BuildParams=".";
  fi;

  echo "";
  echo -e " \e[1;37m[ Module Zip Maker by Adrian DC - 2016 ]\e[0m";
  echo "";

  echo "";
  if [ -d "$(readlink -f "$path")" ]; then
    mmm -B $BuildParams | tee $LogFile;
  else
    mka $BuildParams | tee $LogFile;
  fi;
  Installs=$(grep "target/product/.*/system" $LogFile | sort | uniq);

  FilesList="";
  for FilePath in ${Installs[*]}
  do
    if [[ "$FilePath" =~ "/system" ]]; then
      FilePath=$(printf "$FilePath" | tail -1 \
               | sed "s/\x1B\[[0-9;]*[JKmsu]//g" \
               | sed "s/.*\/\([^\[]*.zip\).*/\1/g");
      FileTarget=$(echo $FilePath \
                 | sed "s/.*\(system\/.*\)/\1/g");
      FileDir=$(dirname $FileTarget);
      if [ ! -d "$TmpDir/$FileDir" ]; then
        mkdir -p "$TmpDir/$FileDir";
      fi;
      if [ -f "$FilePath" ]; then
        cp "$FilePath" "$TmpDir/$FileTarget";
        FilesList="$FilesList ./$FileTarget";
      fi;
    fi;
  done;

  cd "$TmpDir/";
  cp "$bash_android_flashable_zip" "$TmpDir/$OutFile.unsigned.zip";
  zip -g "$TmpDir/$OutFile.unsigned.zip" $FilesList;
  java -jar "$bash_android_sign_apk_dir/signapk-cm121.jar" \
       -w "$bash_android_sign_apk_dir/testkey.x509.pem" \
       "$bash_android_sign_apk_dir/testkey.pk8" \
       "$TmpDir/$OutFile.unsigned.zip" \
       "$TmpDir/$OutFile";
  rm -f "$TmpDir/$OutFile.unsigned.zip";
  cp "$TmpDir/$OutFile" "$TargetFile";
  echo "";
  echo -e " \e[1;37mPackage File:\e[0m $TargetFile";
  echo "";

  rm -rf "$TmpDir";
  cd "$CurDir";
}

# === Kernel Zip Maker ===
function kerzip()
{
  CurDir=$(pwd);
  TmpDir=$(mktemp -d);
  LogFile="$TmpDir/logs.txt";
  if [ ! -z "$1" ]; then FileTag="-$1"; else FileTag=""; fi;
  OutFile="kernel-"$(date +'%Y%m%d-%H%M')"-${TARGET_PRODUCT}${FileTag}.zip";
  TargetFile="$(xdg-user-dir DESKTOP)/Builds/$OutFile";
  mkdir -p $(dirname $TargetFile);
  croot;

  echo "";
  echo -e " \e[1;37m[ Flashable Kernel Builder by Adrian DC - 2016 ]\e[0m";
  echo "";
  printf "";

  touch 'device/sony/huashan/rootdir/init.qcom.rc';

  if $(mms -v >/dev/null 2>&1); then
    mms -j$(grep -c ^processor /proc/cpuinfo) bootimage | tee $LogFile;
  else
    make -j$(grep -c ^processor /proc/cpuinfo) bootimage | tee $LogFile;
  fi;

  BootImg=$(grep -a ".*image.*boot\.img" $LogFile | head -1 \
          | sed "s/.*: \(.*boot\.img\).*/\1/g");

  if [ ! -z "$BootImg" ] && [ -f "$BootImg" ]; then
    ModulesDir=$(grep -a ".*system/lib/.*" $LogFile | head -1 \
               | sed "s/.* \(\S*system\/lib\/modules\S*\);.*/\1/g");
    Modules=$(grep -a ".*INSTALL .*\.ko.*" $LogFile \
            | sed "s/.*INSTALL \(.*\.ko\).*/\1/g" \
            | uniq);
    if [ ! -z "$Modules" ]; then
      Modules=$(echo $Modules | xargs -n 1 basename);
    fi;

    FilesList="";
    ModulesSysDir="system/lib/modules";
    ModulesTmpDir="$TmpDir/$ModulesSysDir";

    if [ ! -d "$ModulesTmpDir" ]; then
      mkdir -p "$ModulesTmpDir/";
    fi;

    for Module in ${Modules[*]}; do
      ModuleName=$(basename "$Module");
      ModuleFile=${ModulesDir}/${ModuleName};
      if [ -f "$ModuleFile" ]; then
        cp "$ModuleFile" "$ModulesTmpDir";
        FilesList="$FilesList ./$ModulesSysDir/$ModuleName";
      fi;
    done;

    cp "$BootImg" "$TmpDir/boot.img";
    FilesList="$FilesList $(basename $BootImg)";

    cd "$TmpDir/";
    cp "$bash_kernel_template_zip" "$TmpDir/$OutFile.unsigned.zip";
    zip -g "$TmpDir/$OutFile.unsigned.zip" $FilesList;
    java -jar "$bash_android_sign_apk_dir/signapk-cm121.jar" \
        -w "$bash_android_sign_apk_dir/testkey.x509.pem" \
        "$bash_android_sign_apk_dir/testkey.pk8" \
        "$TmpDir/$OutFile.unsigned.zip" \
        "$TmpDir/$OutFile";
    rm -f "$TmpDir/$OutFile.unsigned.zip";
    cp "$TmpDir/$OutFile" "$TargetFile";
    echo "";
    echo -e " \e[1;36mPackage File:\e[0m $TargetFile";
    echo "";
  fi;

  rm -rf "$TmpDir";
  cd "$CurDir";
}


# === Binary Editor ===
function binaryeditor()
{
  if [ -z "$2" ]; then
    echo " Usage : binaryeditor binariespath pattern [replacement]";
    return;
  fi;

  local FILES="$1";
  local PATTERN="$2";
  local REPLACEMENT="$3";
  local REPLACE="";
  local STRINGS="";
  PATTERN=${PATTERN//\*/.\*};
  PATTERN=${PATTERN//./.};

  echo "";
  if [ ! -z "${REPLACEMENT}" ]; then
    echo -e " \e[1;31m=== Replacing '${PATTERN}' with '${REPLACEMENT}' in ${FILES} ===\e[0m";
  else
    echo -e " \e[1;31m=== Searching '${PATTERN}' in ${FILES} ===\e[0m";
  fi;
  echo "";
  for FILE in $(find $FILES -not -path "*.git/*" -not -path "*.repo/*" | sort);
  do
    FILE=$(readlink -f "$FILE");
    if [ -d $FILE ]; then continue; fi;

    if [ ! -z "${REPLACEMENT}" ]; then
      STRINGS=$(strings ${FILE} | grep "${PATTERN}" | sort -u -r);

      if [ ! -z "${STRINGS}" ]; then
        printf "   \e[1;37m${FILE} :\e[0m ${STRINGS} ";
        for OLD_STRING in ${STRINGS};
        do
          NEW_STRING=${OLD_STRING//${PATTERN}/${REPLACEMENT}};

          OLD_STRING_HEX="$(echo -n ${OLD_STRING} | xxd -g 0 -u -ps -c 256)00";
          NEW_STRING_HEX="$(echo -n ${NEW_STRING} | xxd -g 0 -u -ps -c 256)00";

          if [ ${#NEW_STRING_HEX} -le ${#OLD_STRING_HEX} ]; then
            while [ ${#NEW_STRING_HEX} -lt ${#OLD_STRING_HEX} ];
            do
              NEW_STRING_HEX="${NEW_STRING_HEX}00";
            done;

            printf "\e[1;36m[y/N] \e[0m";
            read -s -d'' -s -n1 REPLACE;
            if [[ "${REPLACE}" == "y" || "${REPLACE}" == "Y" ]]; then
              hexdump -ve '1/1 "%.2X"' ${FILE} | \
                sed "s/${OLD_STRING_HEX}/${NEW_STRING_HEX}/g" | \
                xxd -r -p > ${FILE}.tmp;
              chmod --reference ${FILE} ${FILE}.tmp;
              mv ${FILE}.tmp ${FILE};
              echo -e "\e[1;32mDone!\e[0m";
            else
              echo -e "\e[1;33mIgnored.\e[0m";
            fi;
          else
            echo -e "\e[1;36m[N] \e[1;33mString too long...\e[0m";
          fi;
        done;
      else
        STRINGS=$(strings ${FILE} | grep ${REPLACEMENT} | sort -u -r);
        if [ ! -z "${STRINGS}" ]; then
          echo -e "   \e[1;37m${FILE}:\e[0m ${REPLACEMENT} \e[1;33mFound.\e[0m";
        fi;
      fi;

    else
      STRINGS=$(strings ${FILE} | grep "${PATTERN}" | sort -u -r | tr '\n' ',');
      if [ ! -z "${STRINGS}" ]; then
        echo -e "   \e[1;37m${FILE}:\e[1;33m ${STRINGS}\e[0m";
      fi;
    fi;
  done;
  echo "";
}

# === Notifications ===
function pushb()
{
  # PushBullet API Credentials
  export PushBulletToken="token";
  export PushBulletUser="user";
  export PushBulletNoteUrl="url";

  # Create  ~/.bash_android.pushbullet.rc with the exports to override the credentials
  if [ -f ~/.bash_android.pushbullet.rc ]; then
    source ~/.bash_android.pushbullet.rc;
  fi;

  # PushBullet notification message
  if [ ! -z "$1" ]; then
    PushBulletComment="$1";
    PushBulletNoteUrl="";
  else
    PushBulletComment="Done";
  fi;

  # PushBullet notification upload
  curl --header "Access-Token: $PushBulletToken" \
       --header "Content-Type: application/json" \
       --data-binary "{\"body\":\"$PushBulletComment\",\"title\":\"\",\"type\":\"note\", \
                       \"url\":\"$PushBulletNoteUrl\",\"created\":\"$(date +%s)\", \
                       \"active\":\"true\",\"sender_name\":\"$PushBulletUser\"}" \
       --request POST https://api.pushbullet.com/v2/pushes >/dev/null;
}

# === CleanRAM ===
function cleanram()
{
  free;
  sudo echo '';

  commands=$(echo \
    'sudo sync
     swapoff -a
     echo 1 > /proc/sys/vm/drop_caches
     echo 2 > /proc/sys/vm/drop_caches
     echo 3 > /proc/sys/vm/drop_caches
     swapon -a' \
    | sed 's/^ *//g');
  OLDIFS="$IFS";
  IFS=$'\n';
  for command in $commands
  do
    echo " [$command]";
    sudo sh -c "timeout 5 $command";
  done;
  IFS="$OLDIFS";

  echo "";
  free;
}
